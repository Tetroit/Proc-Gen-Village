using Generation;
using UnityEngine;
using TetraUtils;
using System.Collections.Generic;
using Unity.VisualScripting;

using GeoUt = TetraUtils.GeometryUtils;
using GenUt = GenerationUtils;
using System.Xml.Schema;
using UnityEditor.Experimental.GraphView;
using static UnityEngine.Tilemaps.Tilemap;

public class RectangularHouse : MonoBehaviour, IHouseGenerator
{
    MeshBuilder builder;
    HouseArea area;
    /// <summary>
    /// bounds generated by the city generator
    /// </summary>
    Rect bounds;
    /// <summary>
    /// resized bounds to fit the grid
    /// </summary>
    Rect snappedBounds;
    /// <summary>
    /// bounds in grid space
    /// </summary>
    RectInt schematicBounds;
    List<IModuleGenerator> modules = new List<IModuleGenerator>();
    [SerializeField] PrefabList prefabList;
    HouseGrid grid;

    [SerializeField] float blockSize = 5;
    float margin = 5;
    float elevation;

    [Header("Entrance Settings")]
    [SerializeField][Range(0, 1)] float pathChance = 0.5f;
    [SerializeField][Range(0, 1)] float pathChanceDecay = 0.01f;
    [SerializeField][Range(0, 1)] float queueStackFac = 0.5f;

    //Vector2[] corners;
    Vector3[] GetCorners()
    {
        Vector3[] res = new Vector3[4];

        res[0] = new Vector3(bounds.min.x, 0.0f, bounds.min.y);
        res[1] = new Vector3(bounds.min.x, 0.0f, bounds.max.y);
        res[2] = new Vector3(bounds.max.x, 0.0f, bounds.max.y);
        res[3] = new Vector3(bounds.max.x, 0.0f, bounds.min.y);

        return res;
    }
    Vector2[] GetCorners2D()
    {
        Vector2[] res = new Vector2[4];

        res[0] = new Vector2(bounds.min.x, bounds.min.y);
        res[1] = new Vector2(bounds.min.x, bounds.max.y);
        res[2] = new Vector2(bounds.max.x, bounds.max.y);
        res[3] = new Vector2(bounds.max.x, bounds.min.y);

        return res;
    }
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }
    private void OnEnable()
    {
        builder = new MeshBuilder();

    }

    //--------------------------------------------------------------------------------
    //                                  GENERATION METHODS
    //--------------------------------------------------------------------------------
    public void Generate(HouseArea info)
    {
        elevation = info.elevation;
        bounds = new Rect(-info.obb.a1.magnitude/2, -info.obb.a2.magnitude/2, info.obb.a1.magnitude, info.obb.a2.magnitude);
        var corners = GetCorners();
        transform.localPosition = new Vector3(info.obb.center.x, elevation, info.obb.center.y);
        transform.localRotation = Quaternion.Euler(0, -info.rotation * Mathf.Rad2Deg, 0);
        blockSize = info.blockSize;

        StageRect(bounds, Color.red, 0);
        Generate();
    }
    public void Generate()
    {
        GizmoManager.Instance?.Clear(transform);
        modules?.Clear();
        grid?.Reset();
        for (int i=transform.childCount-1; i>=0; i--)
        {
            DestroyImmediate(transform.GetChild(0).gameObject);
        }

        BuildBase();
        BuildMainModule();
        BuildSideModule();
        BuildEntrance();

        ResolveGrid();

        //Gizmo
        for (int h = 0; h < grid.floors; h++)
        {
            for (int x = 0; x < grid.Size.x; x++)
            {
                for (int y = 0; y < grid.Size.y; y++)
                {
                    Vector3 pos = new Vector3(
                        (x + 0.5f) * blockSize + snappedBounds.x,
                        (h + 1f)*  blockSize,
                        (y + 0.5f) * blockSize + snappedBounds.y);

                    switch (grid[h, x, y])
                    {
                        case 1:
                            GizmoManager.Instance.StagePoint(pos, Color.red, 1, transform);
                            break;
                        case 2:
                            GizmoManager.Instance.StagePoint(pos, Color.magenta, 1, transform);
                            break;
                        case 3:
                            GizmoManager.Instance.StagePoint(pos, Color.yellow, 1, transform);
                            break;
                    }
                }
            }
        }
    }
    void BuildBase()
    {
        Vector2[] verts = GetCorners2D();
        Vector2Int size = new Vector2Int((int)(bounds.width / blockSize), (int)(bounds.height / blockSize));
        snappedBounds = new Rect(GeoUt.Random2(verts[0], verts[0] + new Vector2(bounds.width%blockSize, bounds.height % blockSize)), 
            new Vector2(
                bounds.width - bounds.width % blockSize, 
                bounds.height - bounds.height % blockSize));
        schematicBounds = new RectInt(Vector2Int.zero, size);
        StageRectGrid(snappedBounds, Color.yellow, area.elevation, new Vector2(blockSize,blockSize));

        grid = new HouseGrid(size);
    }

    void BuildMainModule()
    {
        //x = 0
        //y = 1
        int orientation = (schematicBounds.width >= schematicBounds.height) ? 0 : 1;

        int moduleX, moduleY;
        if (orientation == 1)
        {
            moduleX = Random.Range(schematicBounds.width / 2 + 1, schematicBounds.width);
            moduleX -= moduleX % 2;
            moduleY = Random.Range(schematicBounds.height * 3 / 4, schematicBounds.height);
        }
        else
        {
            moduleX = Random.Range(schematicBounds.width * 3 / 4, schematicBounds.width);
            moduleY = Random.Range(schematicBounds.height / 2 + 1, schematicBounds.height);
            moduleY -= moduleY % 2;
        }
        Vector2Int moduleSize = new Vector2Int(moduleX, moduleY);
        Vector2Int modulePos = GeoUt.Random2(Vector2Int.zero, schematicBounds.size - moduleSize);
        ModuleInfo info = new ModuleInfo(prefabList, orientation, new RectInt(modulePos, moduleSize), snappedBounds);

        var moduleObj = new GameObject("RectModule", typeof(RectangularModule));
        moduleObj.transform.SetParent(transform);
        moduleObj.transform.localPosition = new Vector3(snappedBounds.x + modulePos.x * blockSize, 0, snappedBounds.y + modulePos.y * blockSize);
        moduleObj.transform.localScale = new Vector3(blockSize, blockSize, blockSize);
        moduleObj.transform.localRotation = Quaternion.identity;

        var newModule = moduleObj.GetComponent<RectangularModule>();
        newModule.Generate(ref info, ref grid);
        modules.Add(newModule);
    }
    void BuildSideModule()
    {
        var module = modules[0];
        var mainModuleBounds = module.GetSchematicBounds();
        var moduleHeight = module.GetHeight();
        var mainOrientation = module.GetFacing();

        bool found = false;
        int side = 0;
        int orientation = 0;
        List<int> allowedSides = new() { (mainOrientation + 1) % 4, (mainOrientation + 3) % 4};
        List<Vector2Int> freeWalls = new();
        Vector2Int size = Vector2Int.zero;
        Vector2Int pos = Vector2Int.zero;
        while (!found)
        {
            if (allowedSides.Count == 0) return;
            side = DataUtils.PickRandom(allowedSides);
            orientation = side % 2;

            int inLim = GenUt.GetDirectionLimit(side, mainModuleBounds);
            int outLim = GenUt.GetDirectionLimit(side, schematicBounds);
            int freeDist = outLim - inLim;
            if (freeDist < 2)
            {
                allowedSides.Remove(side);
                continue;
            }

            RangeInt range = GenUt.GetRectWall(side, mainModuleBounds);

            size = orientation == 0 ?
                new Vector2Int(freeDist, 2) :
                new Vector2Int(2, freeDist);

            for (int i = range.start; i < range.end - 1; i++)
            {
                pos = orientation == 0 ?
                    new Vector2Int(inLim + GenUt.GetDirection(side).x, i) :
                    new Vector2Int(i, inLim + GenUt.GetDirection(side).y);
                RectInt blueprintArea = new RectInt(pos, size);
                if (grid.IsTaken(blueprintArea, 0))
                    continue;

                freeWalls.Add(pos);
                found = true;
            }
        }
        pos = DataUtils.PickRandom(freeWalls);
        ModuleInfo info = new ModuleInfo(prefabList, side, new RectInt(pos, size), snappedBounds);

        var moduleObj = new GameObject("SideModule", typeof(SideBuildModule));
        moduleObj.transform.SetParent(transform);
        moduleObj.transform.localPosition = new Vector3(snappedBounds.x + pos.x * blockSize, 0, snappedBounds.y + pos.y * blockSize);
        moduleObj.transform.localScale = new Vector3(blockSize, blockSize, blockSize);
        moduleObj.transform.localRotation = Quaternion.identity;

        var newModule = moduleObj.GetComponent<SideBuildModule>();
        newModule.Generate(ref info, ref grid);
        modules.Add(newModule);
    }

    void BuildEntrance()
    {
        var module = modules[0];
        var mainModuleBounds = module.GetSchematicBounds();
        var moduleHeight = module.GetHeight();

        bool found = false;
        int side = 0;
        int orientation = 0;
        List<int> allowedSides = new() { 0, 1, 2, 3 };
        List<Vector2Int> freeWalls = new();
        while (!found)
        {
            if (allowedSides.Count == 0) return;
            side = DataUtils.PickRandom(allowedSides);
            orientation = side % 2;

            int inLim = GenUt.GetDirectionLimit(side, mainModuleBounds);
            int outLim = GenUt.GetDirectionLimit(side, schematicBounds);
            if (outLim == inLim)
            {
                allowedSides.Remove(side);
                continue;
            }

            RangeInt range = GenUt.GetRectWall(side, mainModuleBounds);

            for (int i = range.start; i < range.end; i++)
            {
                Vector2Int wallPos = orientation == 0 ?
                    new Vector2Int(inLim + GenUt.GetDirection(side).x, i) :
                    new Vector2Int(i, inLim + GenUt.GetDirection(side).y);

                if (IsTaken(wallPos))
                    continue;

                freeWalls.Add(wallPos);
                found = true;
            }
        }
        var entrancePos = DataUtils.PickRandom(freeWalls);
        RectInt moduleBounds = new RectInt(entrancePos, Vector2Int.zero);

        var moduleObj = new GameObject("EntranceModule", typeof(EntranceModule));
        ModuleInfo info = new ModuleInfo(prefabList, side, moduleBounds, snappedBounds);
        moduleObj.transform.SetParent(transform);
        moduleObj.transform.localPosition = new Vector3(snappedBounds.x + entrancePos.x * blockSize, 0, snappedBounds.y + entrancePos.y * blockSize);
        moduleObj.transform.localScale = new Vector3(blockSize, blockSize, blockSize);
        moduleObj.transform.localRotation = Quaternion.identity;

        var newModule = moduleObj.GetComponent<EntranceModule>();
        newModule.chance = pathChance;
        newModule.chanceReduction = pathChanceDecay;
        newModule.queueStackFac = queueStackFac;
        newModule.Generate(ref info, ref grid);
        modules.Add(newModule);

    }

    HashSet<int> wallMask = new HashSet<int>() { -1, 0, 3, 5 };
    public void ResolveGrid()
    {
        for (int h = 0; h < grid.floors; h++)
            for (int x = 0; x < grid.Size.x; x++)
                for (int y = 0; y < grid.Size.y; y++)
                {
                    int val = grid[h, x, y];
                    if (val == 0) continue;
                    if (val == 1)
                    {
                        for (int dir = 0; dir < 4; dir++)
                        {
                            var pos = new Vector2Int(x, y);
                            var otherPos = pos + GenUt.GetDirection(dir);
                            int other = grid.GetNeighbourInDir(dir, pos, h);
                            if (wallMask.Contains(other))
                            {
                                var block = Instantiate(prefabList.GetPrefab("wall"), transform);
                                block.name = $"wall {h}::{x}-{y}:{otherPos.x}-{otherPos.y}";
                                block.transform.localEulerAngles = new Vector3(0, (dir) * 90, 0);
                                block.transform.localScale = new Vector3(blockSize, blockSize, blockSize);
                                block.transform.localPosition = GridToLocal(h, x, y);

                                //generate fundament along with the first floor
                                if (h == 0)
                                {
                                    var fundBlock = Instantiate(prefabList.GetPrefab("fundament"), transform);

                                    fundBlock.name = $"fund {h}::{x}-{y}:{otherPos.x}-{otherPos.y}";
                                    fundBlock.transform.localEulerAngles = new Vector3(0, (dir) * 90, 0);
                                    fundBlock.transform.localScale = new Vector3(blockSize, blockSize, blockSize);
                                    fundBlock.transform.localPosition = GridToLocal(h, x, y) - new Vector3(0, blockSize, 0);
                                }
                            }
                        }
                        continue;
                    }
                }
    }
    //--------------------------------------------------------------------------------
    //                                  GIZMO METHODS
    //--------------------------------------------------------------------------------
    void StageRect(Rect rect, Color col, float h)
    {
        Vector3[] corners = new Vector3[]
        {
            new Vector3(rect.xMin, h, rect.yMin),
            new Vector3(rect.xMin, h, rect.yMax),
            new Vector3(rect.xMax, h, rect.yMax),
            new Vector3(rect.xMax, h, rect.yMin),
        };

        GizmoManager.Instance.StageLine(corners[0], corners[1], col, transform);
        GizmoManager.Instance.StageLine(corners[1], corners[2], col, transform);
        GizmoManager.Instance.StageLine(corners[2], corners[3], col, transform);
        GizmoManager.Instance.StageLine(corners[3], corners[0], col, transform);
    }
    void StageRectGrid(Rect rect, Color col, float h, Vector2 gridCell)
    {
        Vector3[] corners = new Vector3[]
        {
            new Vector3(rect.xMin, h, rect.yMin),
            new Vector3(rect.xMin, h, rect.yMax),
            new Vector3(rect.xMax, h, rect.yMax),
            new Vector3(rect.xMax, h, rect.yMin),
        };

        GizmoManager.Instance.StageLine(corners[0], corners[1], col, transform);
        GizmoManager.Instance.StageLine(corners[1], corners[2], col, transform);
        GizmoManager.Instance.StageLine(corners[2], corners[3], col, transform);
        GizmoManager.Instance.StageLine(corners[3], corners[0], col, transform);
        for (float x = rect.xMin; x < rect.xMax; x += gridCell.x)
        {
            Vector3 pos1 = new Vector3(x, h, rect.yMin);
            Vector3 pos2 = new Vector3(x, h, rect.yMax);
            GizmoManager.Instance.StageLine(pos1, pos2, col, transform);
        }
        for (float y = rect.yMin; y < rect.yMax; y += gridCell.y)
        {
            Vector3 pos1 = new Vector3(rect.xMin, h, y);
            Vector3 pos2 = new Vector3(rect.xMax, h, y);
            GizmoManager.Instance.StageLine(pos1, pos2, col, transform);
        }
    }
    void StagePoly(List<Vector3> corners, Color col, float h)
    {
        for (int i = 0; i < corners.Count - 1; i++)
        {
            Vector3 pos1 = corners[i];
            Vector3 pos2 = corners[i + 1];

            GizmoManager.Instance.StageLine(pos1, pos2, col, transform);
        }

        GizmoManager.Instance.StageLine(corners[^1], corners[0], col, transform);
    }
    void StagePoly(List<Vector2> corners, Color col, float h)
    {
        for (int i = 0; i < corners.Count - 1; i++)
        {
            Vector3 pos1 = GeoUt.MapToWorld(corners[i], h);
            Vector3 pos2 = GeoUt.MapToWorld(corners[i + 1], h);

            GizmoManager.Instance.StageLine(pos1, pos2, col, transform);
        }
        GizmoManager.Instance.StageLine(GeoUt.MapToWorld(corners[^1]), GeoUt.MapToWorld(corners[0]), col, transform);
    }

    //--------------------------------------------------------------------------------
    //                                  UTIL METHODS
    //--------------------------------------------------------------------------------

    bool IsTaken(Vector2Int pos)
    {
        for (int j = 1; j < modules.Count; j++)
        {
            if (modules[j].GetSchematicBounds().Contains(pos))
                return true;

        }
        return false;
    }

    Vector3 GridToLocal(int h, int x, int y)
    {
        Vector3 pos = new Vector3(
            (x + 0.5f) * blockSize + snappedBounds.x,
            (h) * blockSize,
            (y + 0.5f) * blockSize + snappedBounds.y);
        return pos;
    }
}
